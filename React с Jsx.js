// В JSX тип элемента указывается с помощью тега. Его атрибуты представляют свойства. Дочерние элементы к создаваемому элементу могут добавляться между открывающим и закрывающим тегами.

// Когда данному компоненту передается массив ингредиентов, его нужно заключить в фигурные скобки. Это называется выражением JavaScript и должно использоваться при передаче значений JavaScript компонентам в качестве свойств.

// IngredientsList с деревом вложенных компонентов Ingredient
<IngredientsList>
    <Ingredient />
    <Ingredient />
    <Ingredient />
</IngredientsList>

    // Поскольку class является в JavaScript зарезервированным словом, для определения атрибута class вместо него используется className:
    <h1 className="fancy">Baked Salmon</h1>

    // Например, если нужно отобразить в элементе значение свойства title, то можно вставить это значение, используя выражение JavaScript. Переменная будет вычислена, а ее значение возвращено:
    <h1>{this.props.title}</h1>
    // Значения типов, отличных от строки, должны также фигурировать в качестве выражений JavaScript:
    <input type="checkbox" defaultChecked={false} />

    // Будут выполнены такие операции, как объединение или добавление, а также вызваны функции, найденные в выражении JavaScript:

    <h1>{"Hello" + this.props.title}</h1>
    <h1>{this.props.title.toLowerCase().replace}</h1>
    function appendTitle({ this.props.title }) {
    console.log(`${this.props.title} is great!`)
}

// Array.map() с применением кода JSX
<ul>
    {this.props.ingredients.map((ingredient, i) =>
        <li key={i}>{ingredient}</li>
    )}
</ul>

// Код JSX выглядит понятым и легко читаемым, но не может интерпретироваться браузером. Весь код JSX должен быть преобразован в вызовы функции createElement или в вызовы фабрик. И к счастью, для решения этой задачи есть превосходное средство — Babel.

// Для начала можно воспользоваться самым простым из них, включив ссылку на транспилятор babel-core непосредственно в свой HTML что приведет к транспиляции любого кода в блоках сценария, имеющих тип text/babel. Babel транспилирует исходный код на стороне клиента до запуска. Хотя с точки зрения производительности это будет не самым лучшим решением, но для начала работы с JSX ничего лучшего придумать просто невозможно.

// Включение babel-core
//     <!DOCTYPE html >
//         <html>
//             <head>
//                 <meta charset="utf-8">
//                     Babel 95
//         <title>React Examples</title>
//     </head>
//                 <body>
//                     <div class="react-container"></div>
//                     <!-- Библиотеки React и ReactDOM -->
//             <script src="https://unpkg.com/react@15.4.2/dist/react.js"></script>
//                     <script src="https://unpkg.com/react-dom@15.4.2/dist/react-dom.js"></script>
//                     <script
//                         src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.29/browser.js">
//                     </script>
//                     <script type="text/babel">
//                     // Здесь размещается код JSX. Или же ссылка
//                     // на отдельный файл JavaScript, содержащий код JSX
//                     </script>
//                 </body>
// </html>

{/* Вам нужен Babel v5.8 Для транспиляции кода в браузере воспользуйтесь Babel v5.8. Версии Babel 6.0+ в качестве преобразователей, загруженных в браузер, работать не будут. */ }

{/* Кулинарные рецепты https://codepen.io/Kvadeck/pen/eYmyNjv */ }

{/* Заготовки Babel
В Babel 6 возможные преобразования разбиты на модули, названные заготовками (presets). Это требует от специалистов четкого определения запускаемых преобразований путем указания того, какие именно заготовки следует использовать. Цель заключалась в повышении повсеместной модульности, позволяющей разработчикам принимать решение, какой именно синтаксис будет подвергаться преобразованию. Дополнительные модули распределены по нескольким категориям, оптимизированным на основе потребностей приложения. Вероятнее всего, вам придется применять следующие заготовки:

• babel-preset-es2015 — компилирует код ES2015 или ES6 в код ES5;
• babel-preset-es2016 — компилирует то, что имеется в ES2016, в код ES2015;
• babel-preset-es2017 — компилирует то, что имеется в ES2017, в код ES2016;
• babel-preset-env — компилирует все из кодов ES2015, ES2016, ES2017.

Является обобщением всех трех предыдущих заготовок;
• babel-preset-react — компилирует код JSX в вызовы React.createElement. */}

{/* Когда в спецификацию ECMAScript предлагают включить новую функцию, она проходит несколько стадий одобрения, от стадии 0, Strawman (только что предложенная и исключительно экспериментальная), до стадии 4, Finished (одобренная в качестве составной части стандарта). Babel предлагает заготовки для каждой из этих стадий, так что вы можете выбирать стадию, которую разрешите в вашем приложении:

• babel-preset-stage-0: Strawman;
• babel-preset-stage-1: Proposal;
• babel-preset-stage-2: Draft;
• babel-preset-stage-3: Candidate. */}

{/* Webpack считается сборщиком (упаковщиком) модулей, получающим все разнообразие ваших файлов (JavaScript, LESS, CSS, JSX, ES6 и т. д.) и превращающим их в один файл. Модульная сборка имеет два основных преимущества: модульность и высокую сетевую производительность. */ }

{/* Кроме транспиляции, Webpack может выполнять следующие задачи.
Разбиение кода — разбиение кода на разные фрагменты, которые могут загружаться по мере необходимости. Иногда они называются свертками или слоями. Цель заключается в том, чтобы разбить код в соответствии с потребностями различных страниц или устройств.
Минификация — избавление от пробельных символов, разбиений строк, слишком длинных имен переменных и ненужного кода с целью уменьшения размера файла.
Прогон функций (feature flagging) — отправка кода при тестировании его свойств в одну или несколько сред (но не во все).
Замена модулей без полной перезагрузки (hot module replacement, HMR) — отслеживание изменения в исходном коде. Немедленная замена только обновленных модулей. */}

{/* Загрузчик представляет собой функцию, управляющую преобразованиями, которым нужно подвергнуть код в ходе сборки. Если в приложении используются код ES6, JSX, CoffeeScript и другие синтаксические усовершенствования языка, которые не могут естественным образом быть прочитаны браузером, то в файле webpack.config.js указываются необходимые загрузчики для выполнения работы по преобразованию кода в синтаксис, понятный браузеру. */ }

{/* Применяя сборщик пакетов в модули Webpack, можно также получить следующие преимущества.
Модульность — использование такого модульного шаблона, как CommonJS,
для экспорта модулей, которые впоследствии будут импортированы или востребованы другими частями приложения, сделает ваш исходный код более доступным. Это упростит совместную работу команд разработчиков, позволяя им создавать отдельные файлы и работать с ними, а также перед отправкой в виде готовой продукции объединять их в статическом режиме в единый файл.

Возможность составления композиций — работая с модулями, можно собирать
небольшие, простые, многократно применяемые компоненты React, допускающие создание эффективных композиций в рамках приложений. Более мелкие компоненты проще поддаются осмыслению, тестированию и повторному использованию. Их также проще заменять в дальнейшем при расширении приложений.

Скорость — сборка в единый клиентский пакет всех модулей приложения и зависимостей уменьшит время загрузки вашего приложения за счет сокращения задержек, связанных с каждым HTTP-запросом. Сборка всех составляющих в единый файл означает, что клиенту нужно будет сделать всего один запрос. К сокращению времени загрузки приведет и минификация кода, содержащегося в пакете.

Согласованность — поскольку сборщик Webpack выполнит транспиляцию кода JSX в код React, а кода ES6 или даже кода ES7 — в универсальный код JavaScript, мы можем приступать к работе, используя завтрашний синтаксис JavaScript уже сегодня. Babel поддерживает широкий диапазон синтаксиса ESNext, что позволяет не волноваться насчет поддержки браузером нашего
кода. Таким образом, разработчики получают возможность постоянно применять самые последние новинки синтаксиса JavaScript. */}

{/* Компонент IngredientsList, использующий компонент Ingredient */ }

import Ingredient from './Ingredient'
const IngredientsList = ({ list }) =>
    <ul className="ingredients">
        {list.map((ingredient, i) =>
            <Ingredient key={i} {...ingredient} />
        )}
    </ul>
export default IngredientsList

// Каждый ингредиент в массиве list будет отображен на компонент Ingredient. Для передачи всех данных компоненту Ingredient в качестве свойств применяется JSX-оператор распространения.

// Использование оператора распространения:
< Ingredient {...ingredient } />

// Является еще одним способом выражения следующих данных:
< Ingredient amount = { ingredient.amount } measurement = { ingredient.measurement } name = { ingredient.name } />
    // Следовательно, задавая ингредиент с такими полями:

    let ingredient = {
        amount: 1,
        measurement: 'cup',
        name: 'sugar'
    }
// Мы получаем:
< Ingredient amount = { 1} measurement = "cup" name = "sugar" />

// Для создания статического процесса сборки с применением Webpack нужно выполнить ряд установок. Все необходимое устанавливается с помощью npm. Сначала можно было бы глобально установить сам сборщик для повсеместного использования команды webpack:
// sudo npm install -g webpack

// Кроме того, Webpack будет работать с Babel, чтобы транспилировать наш код из JSX и ES6 в код JavaScript, запускаемый в браузере. Для выполнения этой задачи мы собираемся использовать несколько загрузчиков, а также ряд заготовок:
// npm install babel-core babel-loader babel-preset-env babel-preset-react
// babel-preset-stage-0 --save-dev

// В нашем приложении применяются React и ReactDOM. Эти зависимости загружались с помощью тега script. Теперь же мы позволим Webpack добавить их в наш пакет. Для этого нужно выполнить локальную установку зависимостей для React и ReactDOM:
// npm install react react-dom --save
// Тем самым в папку ./node_modules будут добавлены сценарии, необходимые для react и react-dom. Вот теперь у нас есть все необходимое для создания процесса статической сборки с помощью Webpack.

// Чтобы модульное приложение Recipes заработало, нам нужно будет сообщить Webpack, как привязать исходный код к единому файлу. Это можно сделать с помощью конфигурационных файлов, а исходным конфигурационным файлом Webpack неизменно является webpack.config.js.

// Инструкция import ES6
// Мы используем инструкции import ES6, которые пока не поддерживаются большинством браузеров или Node.js. Эти инструкции работают благодаря тому, что Babel в финальном коде преобразует их в инструкции require('модуль/путь');. Обычно модули CommonJS загружаются с помощью функции require.

// Еще одним модулем, экспортирующим литеральный объект JavaScript с описанием
// действий, предпринимаемых Webpack, является файл webpack.config.js. Он должен быть сохранен в корневой папке проекта сразу за файлом index.js.
module.exports = {
    entry: "./src/index.js",
        output: {
        path: "dist/assets",
            filename: "bundle.js"
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /(node_modules)/,
                loader: ['babel-loader'],
                query: {
                    presets: ['env', 'stage-0', 'react']
                }
            }
        ]
    }
}

// Сначала сборщику Webpack указывается, что файлом входа на клиентской стороне будет ./src/index.js. Он должен автоматически выстроить дерево зависимостей на основе инструкций import, начиная с этого файла. Затем указывается, что собранный в пакет файл JavaScript нужно вывести в ./dist/assets/bundle.js. Именно сюда Webpack поместит окончательно собранный пакет JavaScript.
// Следующий набор инструкций для сборщика состоит из списка загрузчиков, запускаемых для указанных модулей. Поле rules является массивом, поскольку с помощью Webpack можно включить множество разнообразных загрузчиков. В данном примере включается только babel.

// Когда возникает необходимость отладки приложения в браузере, сборка кода в один файл может вызвать ряд проблем, избавиться от которых можно за счет предоставления отображения на исходный код. Это файл, отображающий пакет на исходные файлы. Единственное, что нужно сделать для устранения данных проблем при использовании Webpack, — добавить пару строк к нашему файлу
// webpack.config.js
// Webpack.config.js с отображением на исходный код
module.exports = {
    entry: "./src/index.js",
    output: {
        path: "dist/assets",
        filename: "bundle.js",
        sourceMapFilename: 'bundle.map'
    },
    devtool: '#source-map',
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /(node_modules)/,
                loader: ['babel-loader'],
                query: {
                    presets: ['env', 'stage-0', 'react']
                }
            }
        ]
    }
}

// Отображение на исходный код позволит выполнять отладку, применяя исходные файлы. Во вкладке Sources (Источники) инструментов разработчика используемого вами браузера нужно найти папку.

// Используя дополнительные модули Webpack, к процессу сборки можно добавить дополнительные этапы. В данном примере мы собираемся включить в процесс сборки этап минификации нашего выходного пакета, в результате которого произойдет существенное уменьшение размера файла.

// webpack.config.js с дополнительным модулем Uglify
var webpack = require("webpack");
module.exports = {
    entry: "./src/index.js",
    output: {
        path: "dist/assets",
        filename: "bundle.js",
        sourceMapFilename: 'bundle.map'
    },
    devtool: '#source-map',
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /(node_modules)/,
                loader: ['babel-loader'],
                query: {
                    presets: ['env', 'stage-0', 'react']
                }
            }
        ]
    },
    plugins: [
        new webpack.optimize.UglifyJsPlugin({
            sourceMap: true,
            warnings: false,
            mangle: true
        })
    ]
}

// Включение в пакет кода CSS
// Еще одним привлекательным свойством сборщика Webpack является его способность включать код CSS в файл с тем же пакетом, в котором находится код JavaScript. Это позволяет пользователям загружать единый файл, содержащий весь необходимый приложению код CSS и JavaScript. Код CSS может быть включен в пакет с помощью инструкций import. Они указывают сборщику на необходимость включить в пакет файлы CSS, связанные с модулем JavaScript:
import Recipe from './Recipe'
import '../../stylesheets/Menu.css'
const Menu = ({ recipes }) =>
    <article>
        <header>
            <h1>Delicious Recipes</h1>
</header>
        <div className="recipes">
            {recipes.map((recipe, i) =>
                <Recipe key={i} {...recipe} />)
            }
        </div>
    </article>
export default Menu
// Чтобы в конфигурации Webpack реализовать включение в пакет кода CSS, нужно будет установить ряд загрузчиков:
// npm install style-loader css-loader postcss-loader --save-dev
// И наконец, эти загрузчики следует ввести в конфигурацию вашего сборщика Webpack:
rules: [
    {
        test: /\.js$/,
        exclude: /(node_modules)/,
        loader: ['babel-loader'],
        query: {
            presets: ['env', 'stage-0', 'react']
        }
    },
    {
        test: /\.css$/,
        use: ['style-loader', 'css-loader', {
            loader: 'postcss-loader',
            options: {
                plugins: () => [require('autoprefixer')]
            }
        }]
    }
]
// Помещение в пакет файлов CSS с помощью Webpack будет способствовать ускорению загрузки вашего сайта за счет сокращения количества запросов на получение необходимых браузеру ресурсов.

// Чтобы приступить к работе с create-react-app, требуется глобальная установка пакета:
// npm install -g create-react-app
// Затем нужно воспользоваться одноименной командой с указанием названия папки, в которой нужно создать приложение:
// create-react-app my-react-project
// В результате в этой папке будет создан проект React, имеющий всего лишь три зависимости: React, ReactDOM и react-scripts. Инструмент react-scripts, способный творить чудеса, также был создан командой Facebook. Он устанавливает Babel, ESLint, Webpack и другие утилиты, избавляя от необходимости конфигурировать их вручную. В созданной папке проекта находится папка src, содержащая файл App.js. Здесь можно отредактировать корневой компонент и импортировать файлы других компонентов.

// Инструмент create-react-app пригодится как начинающим, так и опытным Reactразработчикам. По мере его совершенствования ожидается расширение его возможностей, поэтому стоит почаще заглядывать на GitHub, чтобы следить за изменениями.