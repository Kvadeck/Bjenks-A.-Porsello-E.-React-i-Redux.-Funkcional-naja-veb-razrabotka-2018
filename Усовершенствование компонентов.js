// Существует два основных вида цикла: жизненный цикл установки и жизненный цикл обновления.

// Жизненный цикл установки отличается в зависимости от того, как создаются компоненты: с помощью синтаксиса ES6 или метода React.createClass. При использовании последнего для получения свойств компонента сначала вызывается метод getDefaultProps. Затем для инициализации состояния вызывается метод
// getInitialState.

// Состояние инициализируется в конструкторе. Доступ к свойствам имеется как у конструкторов класса ES6, так и у метода getInitialState, и, если нужно, их можно задействовать, чтобы помочь определить исходное состояние.

// Жизненный цикл установки компонента:
// Класс ES6:              React.createClass():
//                         getDefaultProps() 
// constructor(props)      getInitialState()
// componentWillMount()    componentWillMount()
// render()                render()
// componentDidMount()     componentDidMount()
// componentWillUnmount()  componentWillUnmount()

// После получения свойств и инициализации состояния вызывается метод componentWillMount. Он вызывается до отображения DOM и может быть использован для инициализации библиотек, созданных сторонними разработчиками, запуска анимаций, запроса данных или выполнения любых дополнительных настроек, которые потребуются перед отображением компонента на экране. Из этого метода можно вызвать метод setState, чтобы изменить состояние компонента непосредственно перед тем, как он будет первоначально отображен на экране.

//https://codepen.io/Kvadeck/pen/RwPaveK?editors=1010

// Использование setState в componentWillMount
// Вызов метода setState перед отображением компонента на экране не запустит жизненный цикл обновления, в отличие от вызова после отображения. Если этот метод вызывается внутри асинхронной функции обратного вызова, определенной в методе componentWillMount, то он будет вызван после отображения компонента на экране и запустит жизненный цикл обновления.

// Метод componentDidMount является еще одним местом, откуда удобно отправлять запросы к API. Он вызывается после отображения компонента на экране, поэтому любые вызовы setState из данного метода приведут к запуску жизненного цикла обновления и к повторному отображению компонента на экране.

// Метод componentDidMount также хорошо подходит для инициализации любого кода JavaScript, созданного сторонними разработчиками, которому требуется DOM. Например, может потребоваться внедрить библиотеку перетаскивания объектов или библиотеку, обрабатывающую события прикосновения к экрану. Обычно таким библиотекам перед их инициализацией требуется DOM.

// Любые процессы, запущенные в componentDidMount или componentWillMount, могут быть прекращены в componentWillUnmount. От неиспользуемых фоновых процессов нужно своевременно избавляться.

// Рассмотрим пример с таймером. Он запускается при установке компонента Clock. Когда пользователь нажимает кнопку закрытия, таймер удаляется, для чего используется метод unmountComponentAtNode, и отсчет времени прекращается.

// https://codepen.io/Kvadeck/pen/mdJPgqZ?editors=1010

// Жизненный цикл обновления представляет собой последовательность методов, вызываемых при изменении состояния компонента или при получении от родительского компонента новых свойств.

// Жизненный цикл обновления запускается при каждом вызове setState.

// Вызов setState внутри жизненного цикла обновления станет причиной бесконечного рекурсивного цикла, который приведет к ошибке переполнения стека. Поэтому метод setState может вызываться только в методе componentWillReceiveProps, позволяющем компоненту обновлять состояние при обновлении его свойств.

// В число методов жизненного цикла обновления входят:
// componentWillReceiveProps(nextProps) — вызывается только в случае передачи компоненту новых свойств; единственный метод, в котором может быть вызван метод setState;
// shouldComponentUpdate(nextProps, nextState) — привратник жизненного цикла обновления: предикат, способный отменить обновление; может использоваться для повышения производительности, разрешая только необходимые обновления;
// componentWillUpdate(nextProps, nextState) — вызывается непосредственно перед обновлением компонента; похож на метод componentWillMount, но вызывается только перед выполнением каждого обновления;
// componentDidUpdate(prevProps, prevState) — вызывается сразу же после выполнения обновления, после вызова метода отображения render; похож на метод componentDidMount, но вызывается только после каждого обновления.

// componentWillMount pen
// https://codepen.io/Kvadeck/pen/NWqragg?editors=1010

// Метод componentWillUpdate будет вызван, только если компонент будет обновляться. В жизненном цикле он следует за методом shouldComponentUpdate. Фон останется серым, пока компоненты Color не будут обновлены путем изменения их рейтингов

// Если метод shouldComponentUpdate возвращает true, то далее следуют остальные действия жизненного цикла обновления. Остальные методы жизненного цикла обновления также получают в виде аргументов новые свойства и новое состояние. (Метод componentDidUpdate получает предыдущие свойства и предыдущее состояние, поскольку, если дело дошло до его применения, значит, обновление уже состоялось и свойства были изменены.)

// Иногда наши компоненты сохраняют состояние, которое изначально устанавливается на основе свойств. Исходное состояние наших классов компонентов можно установить в конструкторе или в методе жизненного цикла componentWillMount. Когда эти свойства изменяются, приходится обновлять состояние с помощью метода componentWillReceiveProps

// HiddenMessages
// https://codepen.io/Kvadeck/pen/yLNJpOO

// API React.Children предоставляет способ работы с дочерними компонентами отдельно взятого компонента. Он позволяет вести их подсчет, выполнять их отображение, циклический обход или превращать props.children в массив. Он также позволяет с помощью React.Children.only убеждаться, что на экран выводится единственный дочерний компонент

// В этом примере компонент Display будет показывать только один дочерний компонент, элемент h1. Если компонент Display содержит несколько дочерних компонентов, то React выдаст сообщение об ошибке: onlyChild must be passed a children with exactly one child (onlyChild должны передаваться дочерние компоненты, имеющие только один дочерний компонент).

// https://codepen.io/Kvadeck/pen/vYOXzJr?editors=1010

// Компонент Display выведет на экран один дочерний элемент, когда условие вычисляется в true, или другой, когда вычисляется в false. Для этого создаются компоненты WhenTruthy и WhenFalsy, которые применяются в компоненте Display в качестве дочерних. Функция findChild использует React.Children для преобразования children в массив. Последний можно отфильтровать, чтобы найти и возвратить отдельно взятый дочерний компонент по типу компонента.

// Подключение библиотек JavaScript
// Такие фреймворки, как Angular и jQuery, поставляются со своими собственными средствами доступа к данным, отображения пользовательского интерфейса, моделирования состояния и т. д. В отличие от них React является простой библиотекой для создания представлений, поэтому может понадобиться взаимодействие с другими библиотеками JavaScript. Если хорошо разбираться в работе функций жизненного цикла, то можно заставить React поладить практически с любой библиотекой JavaScript.

// React с jQuery
// Вообще-то использование jQuery с React не находит одобрения со стороны сообщества. И все же объединить jQuery и React вполне возможно, и это может быть неплохим вариантом для изучения React или перевода устаревшего кода на React. Но приложения работают намного лучше, если к React подключаются библиотеки, имеющие меньший объем, чем большие рабочие среды. Кроме того, при использовании jQuery для непосредственного воздействия на DOM игнорируется применение виртуальной DOM, что может привести к возникновению непонятных ошибок.

// https://codepen.io/Kvadeck/pen/abOmaRV?editors=1010

// В следующем примере компонентом CountryList создается упорядоченный список названия стран. После установки компонент выполняет вызов API и изменяет состояние, чтобы отобразить загрузку данных. Состояние loading имеет значение true до тех пор, пока не поступит ответ на этот вызов

// Подключение D3 Timeline
// Updated with last book changes
// https://codepen.io/Kvadeck/pen/XWmpydr?editors=1011

// Компонент высшего порядка (higher-order component, HOC) представляет собой простую функцию, получающую ввиде аргумента один компонент React ивоз-вращающую другой

// HOC позволяют заключать один компонент вдругой. Родительский компонент мо-жет сохранять состояние или содержать функциональность, пригодную для пере-дачи вниз составному компоненту ввиде свойств. Этому составному компоненту ничего не нужно знать ореализации HOC имен свойств иметодов, ккоторым он открывает доступ.

// Можно создать компонент высшего порядка по имени DataComponent, который может применяться для созда-ния компонентов React, загружающих данные.

// Обратите внимание: компонент DataComponent по сути является функцией. Все ком-поненты высшего порядка— функции. Компонентом, который мы будем заключать, будет ComposedComponent. Возвращенный класс, DataComponent, сохраняет состояние иуправляет им.
// https://codepen.io/Kvadeck/pen/bGVqrGZ

// Управление состоянием за пределами React
// Управление состоянием вReact нас вполне устраивает. Спомощью встроенной вбиблиотеку системы управления состоянием можно создать множество разно-образных приложений. Но когда ваши приложения увеличиваются вобъеме, сле-дить за их состоянием становится сложнее.

// Отображение часов. Ранее, вглаве 3, на основе правил функционального про-граммирования мы создали тикающие часы.
https://codepen.io/Kvadeck/pen/OJygQpK

// Функция высшего порядка для render ежесекундно вызывает ReactDOM.render и обновляет DOM. Такой подход позволяет задействовать преимущество прису-щего React ускоренного отображения DOM, но при этом не требует применения компонента, созданного сприменением класса ииспользующего состояние.

// Flux
// Flux— модель конструирования, разработанная вFacebook сцелью организовать однонаправленный поток данных. До ее появления вархитектуре веб-разработки преобладали различные вариации модели конструирования MVC. Flux является альтернативой MVC, представляя собой абсолютно другую модель конструирова-ния, дополняющую функциональный подход.

// Flux предоставляет способ построения веб-приложений, дополняющий работу React. Если конкретнее, то Flux дает способ предоставления данных, которые React будет использовать для создания пользовательского интерфейса.

// Если пользователь должен взаимодействовать с веб-страницей, например нажимать кнопку или от-правлять данные формы, то для представления пользовательского запроса будет создано действие (action). Оно предоставляет инструкции иданные, требуемые для внесения изменений. Инструкции отправляются спомощью центрального управ-ляющего элемента под названием «диспетчер» (dispatcher).

// Использование Flux не означает, что вкаком-либо из ваших компонентов представления не может быть состояния. Оно говорит отом, что состояние приложения не управляется вваших компонентах представления. Напри-мер, Flux может управлять значениями дат ивремени на шкале времени. Но применять для визуализации шкалы времени вашего приложения компо-ненты этой шкалы, имеющие внутреннее состояние, не запрещается. Состояние нужно задействовать рационально, только вслучае надобности, из повторно используемых компонентов, управляющих своим собственным состоянием внутри самих себя. Остальная часть приложения не должна быть «осведомлена» осостоянии дочернего компонента.

// https://codepen.io/Kvadeck/pen/LYpLBdY

// Действия и создатели действий
// Действия предоставляют инструкции и данные, которые хранилище будет ис-пользовать для изменения состояния. Создатели действий представляют собой функции, благодаря которым можно абстрагировать всевозможные детали, необхо-димые для создания действия. Сами по себе действия— это объекты, как минимум содержащие поле type.

// Когда загружаются создатели действия обратного отсчета, им ввиде аргумента отправляется диспетчер. При каждом инициировании действия TICK или RESET вызывается принадлежащий диспетчеру метод handleAction, который «выполняет диспетчеризацию» объекта действия.

// Диспетчер
// Когда метод handleAction вызывается сдействием, это действие отправляется диспетчером вместе сданными отом, откуда оно взялось. Когда создается храни-
// Flux187лище, оно регистрируется диспетчером иначинает отслеживать действия. При дис-петчеризации действие обрабатывается впорядке его получения иотправляется всоответствующие хранилища.

// Хранилища
// Хранилища представляют собой объекты, вкоторых содержатся логика идан-ные состояния приложения. Хранилища похожи на модели вшаблоне MVC, но не ограничиваются управлением данными водном объекте. Можно создавать Flux-приложения, состоящие из одного хранилища, которое управляет данными, имеющими множество разнообразных типов.

// Для реализации Flux существуют различные подходы. Конкретные реализации этого шаблона проектирования можно найти в нескольких библиотеках с открытым кодом:

// Flux— принадлежащая Facebook библиотека Flux представляет собой только что рассмотренный нами шаблон проектирования; включает реализацию диспетчера;

// Reflux— упрощенный подход кодонаправленному потоку данных, который сконцентрирован на действиях, хранилищах и представлениях;

// Flummox— реализация Flux, позволяющая создавать Flux-модули с помощью расширения классов JavaScript;

// Fluxible— фреймворк Flux, созданный компанией Yahoo! для работы с изоморфными Flux-приложениями;

// Redux— Flux-подобная библиотека, в которой модульность достигается за счет использования функций, а не объектов;

// MobX— библиотека управления состоянием, в которой для реагирования на изменения состояния применяются наблюдаемые объекты.

// Redux
// Мы говорили, что Redux является Flux-подобной библиотекой, но это не совсем Flux. Вней есть действия, создатели действий, хранилище и объекты действий, используемые для изменения состояния. Redux немного упрощает концепции Flux за счет удаления диспетчера и представления состояния приложения спомощью единственного неизменяемого объекта. В Redux также введены преобразователи(reducers), не являющиеся составной частью модели Flux. Преобразователи представляют собой чистые функции, возвращающие новое состояние на основе текущего состояния и действия: (state, action) => newState.

// Redux упрощает способ просмотра состояния в приложении, требуя от нас хранить все данные состояния в одном объекте. Все, что нужно знать о приложении, находится в одном месте: единственном источнике истины.

// При создании Redux-приложений состояние является первым, очем нужно по-думать. Постарайтесь определить его водном объекте. Обычно рекомендуется составлять черновой JSON-проект вашего дерева состояния сместами, предна-значенными для заполнения данными.

// После того как мы разобрались сосновной структурой состояния нашего при-ложения, посмотрим, как это состояние обновляется иизменяется спомощью действий.

// Неизменяемость означает, что этот объект состояния не должен изменяться. Время от времени он будет обновляться за счет его полной замены. Чтобы воплотить данный замысел вжизнь, нам понадобятся инструкции, касающиеся изменений. Именно это ипредоставляют действия: инструкции, касающиеся изменений, вносимых в состояние приложения, которые сопровождаются данными, необходимыми для внесения изменений.

// При создании Redux-приложения хотелось бы сместить мышление всторону концентрации на действиях. Как действия повлияют на данные состояния? После выявления действий их можно перечислить вфайле constants.js

// Константы, перечисленные в файле ./constants.js
// const constants = {    
//     SORT_COLORS: "SORT_COLORS",    
//     ADD_COLOR: "ADD_COLOR",    
//     RATE_COLOR: "RATE_COLOR",    
//     REMOVE_COLOR: "REMOVE_COLOR"
// }
// export default constants

// Действие представляет собой объект JavaScript, имеющий как минимум поле для типа:{ type: "ADD_COLOR" }

// Тип действия является строкой, определяющей то, что должно произойти. ADD_COLOR представляет действие добавления нового цвета к списку в состоянии приложения.

// Опечатка превратится в ошибку в приложении. Ошибки подобного рода зачастую не приводят к выдаче предупреждений; вы просто не увидите в данных состояния ожидаемых изменений. Такие ошибки порой довольно трудно обнаруживаются. Издесь на помощь могут прийти константы: 

// import C from "./constants"
// { type: C.ADD_COLOR }

// Все наше дерево состояния хранится в одном объекте. Возможно, кто-то выразит недовольство из-за недостаточной модульности, если рассматривать ее в виде описания объектов. В Redux модульность достигается за счет функций. Они используются для обновления частей дерева состояния. Эти функции называются преобразователями (reducers).

// Преобразователи представляют собой функции, которые получают текущее состояние и действие в виде аргументов и используют их для создания и возвращения нового состояния.

// Обратите внимание: преобразователь цвета должен быть объектом и возвращает объект.

// Каждый преобразователь предназначен для обработки только тех действий, ко-торые необходимы для обновления его части дерева состояния.

// Действие того же типа, ADD_COLOR, в преобразователе цветов вызовет возвращение массива, имеющего дополнительный объект цвета. Они разработаны для совместной работы. Каждый преобразователь нацелен на реализацию действия, предназначенного именно для его ветви в дереве состояния.

// Объединение преобразователей не требование, а просто рекомендация

// Преобразователи можно запрограммировать несколькими различными способа-ми. Весьма популярным решением является использование инструкций switch, поскольку сих помощью можно обрабатывать различные типы действий, ското-рыми должен работать преобразователь. Он проверяет тип действия action.typeвинструкции switch, азатем обрабатывает каждый тип действия вварианте caseинструкции switch

// https://codepen.io/Kvadeck/pen/gOaGvOe?editors=0011